## Header files

The class definition can be placed before your main function in C++ as shown below.

```c++
#include <iostream>

class Apple {
};

int main(void) {
    return 0;
}
```

This will however make for a terrible mess once your program starts to become bigger. Secondly, it is not possible to share classes like this between different programs without copy pasting the code from one application to another. And that's a big no-no.

For these reasons, class definitions will always be placed in separate files called **header files**. These files carry the same name as the class, though mostly in lower case letters (preferred *snake_case*, although not mandatory), and have the extension ".h".

> #### Warning::Case-sensitivity
>
> Do take note that where Windows is not case-sensitive, other operating systems might be. Take for example Linux. This means that if you are not careful when naming and including your files, you might have a working application on Windows but not on Linux.
>

Take for example a class called `RgbLed`:

```c++
class RgbLed {
};
```

This would be placed inside a file called `rgb_led.h`.

However if you want to create objects of your class somewhere else you will need to tell the compiler where to find the class definition. This can be achieved by **including the header file** using a **preprocessor** `#include` directive.

```c++
#include <iostream>     // Include standard/external libraries
#include "rgb_led.h"    // Include project header files

using namespace std;

int main(void) {
    //...
}
```

As can be seen from the previous example code, there are different ways to use an `#include` directive.
* When using `<....>` with a `#include` directive you are telling the compiler to search for the header file within the **standard libraries of C++** and within the include paths made available to the compiler (for example externally installed libraries).
* When using `"...."` with a `#include` directive you are telling the compiler to search for the header file within the **current project directory**.

### Include Guards

When including files the preprocessor will actually take the content from the header-file and replace the `#include` directive with the content.

> ####Info::Intermediate files
>
> You can actually test this by telling the compiler to save the intermediate files that are generated by the different compiler tools. For example the `.ii` files are the result files of the preprocessor. Pass the argument `-save-temps` to the `g++` compiler and you will be able to access the intermediate files. Open the `.ii` file and take a look how big it has gotten.

Now what happens if you include the same header file multiple times? Actually C++ states that a variable, a function, a class, ... can only be defined once in a single application. This is also known as the **One-Definition Rule (ODR)**. When the linker is uniting all the object modules, it will complain if it finds more than one definition for the same variable/function/class/...

This is where **include guards** come into play. These are a safety mechanism that will make the preprocessor only include header files that have not been included yet. A typical include guard looks something like this:

```c++
#ifndef _HEADER_RGB_LED_
#define _HEADER_RGB_LED_

class RgbLed {

};

#endif
```

Basically it does as the directives state. If the label `_HEADER_RGB_LED_` has not yet been defined, then define it, include the class definition and end it. If the label has already been defined than the class definition is not included anymore. The label can be chosen freely by the developer.

These include guards are only of importance for the preprocessor, therefore they are prefixed with a hashtag (#).

One disadvantage of the include guards as shown above it that you need to declare a label which must be unique throughout your whole program (including all libraries you include). For this a new system was introduced using the `#pragma once` directive. This directive tells the preprocessor to only include the file once. It also makes the code shorter and more clear.

Rewriting the previous example using the `#pragma once` directive look like:

```c++
#pragma once

class RgbLed {

};
```
